
"""
postman_clone.py

Run:
    pip install reactpy httpx
    python postman_clone.py

Open http://localhost:8000 in your browser.

Notes:
- This uses server-side HTTP requests via httpx (so CORS is not an issue).
- History is stored in-memory (lost when server restarts). See comments for how to add file persistence or browser localStorage.
- For production, run behind a proper ASGI server.
"""

import asyncio
import json
import time
from typing import List, Dict, Any

import httpx
from reactpy import component, html, use_state, run, hooks

# Simple dataclasses would be nicer but keeping plain dicts for brevity


@component
def PostmanClone():
    # Request builder state
    method, set_method = use_state("GET")
    url, set_url = use_state("")
    headers, set_headers = use_state([{"id": 1, "key": "", "value": ""}])
    body, set_body = use_state("")
    body_type, set_body_type = use_state("raw")  # raw | form

    # Response + UI state
    response, set_response = use_state(None)  # dict with status, headers, body, time_ms, size
    status_info, set_status_info = use_state({"status": None, "status_text": ""})
    is_loading, set_is_loading = use_state(False)

    # History stored server-side (per-process); newest first
    history, set_history = use_state([])  # each item: dict {id, ts, method, url, headers, body_type, body, response}

    selected_history_id, set_selected_history_id = use_state(None)

    # Helpers for headers
    def add_header_row(event=None):
        set_headers(lambda h: h + [{"id": int(time.time() * 1000), "key": "", "value": ""}])

    def update_header_row(row_id, field, value):
        def updater(h):
            return [({**r, field: value} if r["id"] == row_id else r) for r in h]

        set_headers(updater)

    def remove_header_row(row_id):
        set_headers(lambda h: [r for r in h if r["id"] != row_id] or [{"id": 1, "key": "", "value": ""}])

    def build_headers_object():
        obj = {}
        for r in headers:
            k = (r.get("key") or "").strip()
            if k:
                obj[k] = r.get("value", "")
        return obj

    # Async send request - uses httpx for server-side request
    async def send_request(_event=None, save_to_history: bool = True):
        if not url.strip():
            # Using browser alert is possible with reactpy/js interop, but keep simple: set response with error
            set_response({"status": 0, "status_text": "NO URL", "headers": {}, "body": "Please enter a URL", "time_ms": 0, "size": 0})
            return

        set_is_loading(True)
        set_response(None)
        set_status_info({"status": None, "status_text": ""})
        start = time.time()

        req_headers = build_headers_object()
        # If body is JSON-like and Content-Type not set, set it
        if method not in ("GET", "HEAD"):
            if body_type == "raw":
                if "content-type" not in {k.lower() for k in req_headers}:
                    # try to detect JSON
                    jb = body.strip()
                    if (jb.startswith("{") and jb.endswith("}")) or (jb.startswith("[") and jb.endswith("]")):
                        req_headers["Content-Type"] = "application/json"
            else:
                req_headers["Content-Type"] = "application/x-www-form-urlencoded"

        res_obj = {"status": 0, "status_text": "", "headers": {}, "body": "", "time_ms": 0, "size": 0}

        # perform httpx request with timeout and follow redirects
        try:
            async with httpx.AsyncClient(follow_redirects=True, timeout=30.0) as client:
                # build kwargs
                kwargs = {"headers": req_headers}
                if method not in ("GET", "HEAD"):
                    if body_type == "raw":
                        kwargs["content"] = body.encode("utf-8")
                    else:
                        # treat body as lines key=value
                        data = {}
                        for line in body.splitlines():
                            if "=" in line:
                                k, v = line.split("=", 1)
                                data[k.strip()] = v.strip()
                        kwargs["data"] = data

                http_response = await client.request(method, url, **kwargs)

                res_obj["status"] = http_response.status_code
                res_obj["status_text"] = http_response.reason_phrase or ""
                # headers
                res_obj["headers"] = dict(http_response.headers)
                content_type = http_response.headers.get("content-type", "")
                # attempt to decode JSON if content-type indicates
                try:
                    if "application/json" in content_type.lower():
                        res_body_text = json.dumps(http_response.json(), indent=2)
                    else:
                        res_body_text = http_response.text
                except Exception:
                    # fallback to text
                    res_body_text = http_response.text

                res_obj["body"] = res_body_text
                res_obj["size"] = len(res_body_text.encode("utf-8"))
                res_obj["time_ms"] = int((time.time() - start) * 1000)

                set_response(res_obj)
                set_status_info({"status": res_obj["status"], "status_text": res_obj["status_text"]})

                if save_to_history:
                    hist_item = {
                        "id": int(time.time() * 1000),
                        "ts": time.time(),
                        "method": method,
                        "url": url,
                        "headers": build_headers_object(),
                        "body_type": body_type,
                        "body": body,
                        "response": res_obj,
                    }
                    set_history(lambda h: [hist_item] + h[:199])  # keep up to 200
                    set_selected_history_id(hist_item["id"])

        except Exception as e:
            res_obj["body"] = str(e)
            res_obj["status_text"] = "NETWORK ERROR"
            res_obj["time_ms"] = int((time.time() - start) * 1000)
            set_response(res_obj)
            if save_to_history:
                hist_item = {
                    "id": int(time.time() * 1000),
                    "ts": time.time(),
                    "method": method,
                    "url": url,
                    "headers": build_headers_object(),
                    "body_type": body_type,
                    "body": body,
                    "response": res_obj,
                }
                set_history(lambda h: [hist_item] + h[:199])
                set_selected_history_id(hist_item["id"])
        finally:
            set_is_loading(False)

    # load a history item into UI
    def load_history_item(item):
        set_method(item["method"])
        set_url(item["url"])
        hdrs = item.get("headers", {}) or {}
        if hdrs:
            set_headers([{"id": i + 1, "key": k, "value": v} for i, (k, v) in enumerate(hdrs.items())])
        else:
            set_headers([{"id": 1, "key": "", "value": ""}])
        set_body(item.get("body", ""))
        set_body_type(item.get("body_type", "raw"))
        set_response(item.get("response"))
        set_selected_history_id(item["id"])

    # clear history
    def clear_history(event=None):
        set_history([])
        set_selected_history_id(None)

    # Small helper to format timestamp
    def human_ts(ts):
        return time.strftime("%Y-%m-%d %H:%M:%S", time.localtime(ts))

    # UI rendering
    return html.div(
        {"class_": "h-screen grid grid-cols-5 gap-2 bg-gray-100 font-sans"},
        # Left: history
        html.aside(
            {"class_": "col-span-1 bg-white border-r p-2 flex flex-col"},
            html.div(
                {"class_": "flex items-center justify-between mb-2"},
                html.h2({"class_": "font-semibold"}, "History"),
                html.div({"class_": "text-sm text-gray-500"}, str(len(history))),
            ),
            html.div(
                {"class_": "flex-1 overflow-auto"},
                html.div({"class_": "text-sm text-gray-500"} if not history else None, "No requests yet" if not history else None),
                html.ul(
                    {},
                    *[
                        html.li(
                            {
                                "key": item["id"],
                                "on_click": lambda ev, _item=item: load_history_item(_item),
                                "class_": (
                                    "cursor-pointer p-2 rounded mb-1 " +
                                    ("bg-blue-50 border-l-4 border-blue-400" if selected_history_id == item["id"] else "hover:bg-gray-50")
                                ),
                            },
                            html.div(
                                {"class_": "flex items-center justify-between"},
                                html.div({"class_": "text-xs font-mono"}, human_ts(item["ts"])),
                                html.div({"class_": "text-xs text-gray-500"}, str(item.get("response", {}).get("status", "-"))),
                            ),
                            html.div(
                                {"class_": "mt-1 flex items-center gap-2"},
                                html.div({"class_": "text-xs px-2 py-1 rounded bg-gray-100 font-semibold"}, item["method"]),
                                html.div({"class_": "text-sm truncate"}, item["url"]),
                            ),
                        )
                        for item in history
                    ],
                ),
            ),
            html.div(
                {"class_": "mt-2 flex gap-2"},
                html.button(
                    {"on_click": lambda ev: asyncio.create_task(asyncio.to_thread(lambda: None)),
                     "class_": "flex-1 bg-gray-200 py-2 rounded", "title": "Export first 50 history items to clipboard"},
                    "Export",
                ),
                html.button({"on_click": clear_history, "class_": "flex-1 bg-red-500 text-white py-2 rounded"}, "Clear"),
            ),
        ),
        # Main: request and response builder
        html.main(
            {"class_": "col-span-3 p-4 flex flex-col gap-3"},
            html.div(
                {"class_": "flex gap-2"},
                # method select
                html.select(
                    {
                        "value": method,
                        "on_change": lambda ev: set_method(ev.target.value),
                        "class_": "w-24 p-2 rounded border",
                    },
                    *[html.option({"value": m, "key": m}, m) for m in ("GET", "POST", "PUT", "PATCH", "DELETE", "HEAD", "OPTIONS")]
                ),
                # url
                html.input(
                    {
                        "value": url,
                        "on_change": lambda ev: set_url(ev.target.value),
                        "placeholder": "https://api.example.com/path",
                        "class_": "flex-1 p-2 rounded border",
                    }
                ),
                # send button
                html.button(
                    {"on_click": lambda ev: asyncio.create_task(send_request(ev, True)),
                     "disabled": is_loading,
                     "class_": f"px-4 py-2 rounded {'bg-gray-400' if is_loading else 'bg-blue-600 text-white'}"},
                    "Sending..." if is_loading else "Send",
                ),
                html.button(
                    {
                        "on_click": lambda ev: (set_url(""), set_body(""), set_headers([{"id": 1, "key": "", "value": ""}]), set_response(None)),
                        "class_": "px-3 py-2 rounded border",
                    },
                    "Reset",
                ),
            ),
            # headers + body in one row
            html.div(
                {"class_": "flex gap-4"},
                # headers editor
                html.div(
                    {"class_": "flex-1 bg-white rounded border p-3"},
                    html.div(
                        {"class_": "flex items-center justify-between mb-2"},
                        html.h3({"class_": "font-medium"}, "Headers"),
                        html.div(
                            {"class_": "flex items-center gap-2"},
                            html.button({"on_click": add_header_row, "class_": "text-sm px-2 py-1 rounded border"}, "+ Add"),
                        ),
                    ),
                    html.div(
                        {"class_": "space-y-2 max-h-56 overflow-auto"},
                        *[
                            html.div(
                                {"class_": "flex gap-2 items-center", "key": r["id"]},
                                html.input(
                                    {
                                        "value": r["key"],
                                        "on_change": (lambda rid: (lambda ev: update_header_row(rid, "key", ev.target.value)))(r["id"]),
                                        "placeholder": "Header name",
                                        "class_": "w-40 p-1 rounded border",
                                    }
                                ),
                                html.input(
                                    {
                                        "value": r["value"],
                                        "on_change": (lambda rid: (lambda ev: update_header_row(rid, "value", ev.target.value)))(r["id"]),
                                        "placeholder": "Header value",
                                        "class_": "flex-1 p-1 rounded border",
                                    }
                                ),
                                html.button(
                                    {"on_click": (lambda rid: (lambda ev: remove_header_row(rid)))(r["id"]), "class_": "px-2 py-1 rounded border"},
                                    "Del",
                                ),
                            )
                            for r in headers
                        ],
                    ),
                ),
                # body editor
                html.div(
                    {"class_": "flex-1 bg-white rounded border p-3"},
                    html.div(
                        {"class_": "flex items-center justify-between mb-2"},
                        html.h3({"class_": "font-medium"}, "Body"),
                        html.div(
                            {"class_": "flex items-center gap-2"},
                            html.select(
                                {
                                    "value": body_type,
                                    "on_change": lambda ev: set_body_type(ev.target.value),
                                    "class_": "p-1 border rounded text-sm",
                                },
                                html.option({"value": "raw"}, "raw"),
                                html.option({"value": "form"}, "form"),
                            ),
                            html.div({"class_": "text-xs text-gray-500"}, "Ignored for GET/HEAD" if method in ("GET", "HEAD") else ""),
                        ),
                    ),
                    html.textarea(
                        {
                            "value": body,
                            "on_change": lambda ev: set_body(ev.target.value),
                            "placeholder": '{\n  "key": "value"\n}' if body_type == "raw" else "key=value\nother=val",
                            "class_": "w-full h-48 p-2 rounded border font-mono",
                        }
                    ),
                ),
            ),
            # response header row
            html.div(
                {"class_": "bg-white rounded border p-3 flex items-center justify-between"},
                html.div(
                    {"class_": "flex items-center gap-4"},
                    html.div({"class_": "text-sm"}, "Status: "),
                    html.div({"class_": "font-mono"}, str(status_info.get("status") or "-")),
                    html.div({"class_": "text-sm text-gray-500"}, status_info.get("status_text") or ""),
                    html.div({"class_": "text-sm text-gray-500"}, f"Time: {response['time_ms']} ms" if response else "Time: -"),
                    html.div({"class_": "text-sm text-gray-500"}, f"Size: {response['size']} bytes" if response else "Size: -"),
                ),
                html.div(
                    {"class_": "flex gap-2"},
                    html.button(
                        {
                            "on_click": lambda ev: (
                                asyncio.create_task(asyncio.to_thread(lambda: None)),
                                # we cannot directly access clipboard here server-side; client-side clipboard would need JS interop.
                            ),
                            "class_": "px-3 py-1 border rounded",
                            "title": "Copy Body (client clipboard requires JS interop)",
                        },
                        "Copy Body",
                    ),
                    html.button({"on_click": lambda ev: None, "class_": "px-3 py-1 border rounded"}, "Copy Headers"),
                    html.button(
                        {
                            "on_click": lambda ev: None,
                            "class_": "px-3 py-1 border rounded",
                        },
                        "Download",
                    ),
                ),
            ),
            # response panel
            html.div(
                {"class_": "flex-1 bg-white rounded border p-3 overflow-auto"},
                (html.div({"class_": "text-gray-500"}, "No response yet. Click Send.") if not response else None),
                (response and html.div(
                    {"class_": "space-y-3"},
                    html.div(
                        {},
                        html.h4({"class_": "font-medium mb-1"}, "Response Body"),
                        html.pre({"class_": "bg-gray-50 rounded p-3 max-h-64 overflow-auto whitespace-pre-wrap font-mono text-sm"}, response["body"]),
                    ),
                    html.div(
                        {},
                        html.h4({"class_": "font-medium mb-1"}, "Response Headers"),
                        html.pre({"class_": "bg-gray-50 rounded p-3 max-h-40 overflow-auto font-mono text-sm"}, json.dumps(response["headers"], indent=2)),
                    ),
                )),
            ),
        ),
        # Right inspector
        html.aside(
            {"class_": "col-span-1 p-3"},
            html.div(
                {"class_": "bg-white rounded border p-3"},
                html.h3({"class_": "font-medium mb-2"}, "Inspector"),
                html.div({"class_": "text-sm text-gray-600"}, "Quick actions and info"),
                html.div(
                    {"class_": "mt-3 text-sm"},
                    html.div({"class_": "mb-2"}, html.b({}, "Saved Requests:"), f" {len(history)}"),
                    html.div({"class_": "mb-2"}, html.b({}, "Selected:"), f" {selected_history_id or '-'}"),
                    html.div({"class_": "mb-2"}, html.b({}, "Current URL:"), html.div({"class_": "text-xs font-mono break-words"}, url or "-")),
                ),
            ),
        ),
    )


def main():
    # Run the reactpy app on http://localhost:8000
    print("Starting PostmanClone on http://localhost:8000")
    run(PostmanClone, debug=True, host="0.0.0.0", port=8000)


if __name__ == "__main__":
    main()
